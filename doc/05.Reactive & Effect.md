# Reactive & Effect

## Reactivity 模块基本使用

安装响应式模块

```shell
pnpm install @vue/reactivity -w
```

```html
<div id="app"></div>
<script type="module">
  import {
    reactive,
    effect,
  } from "/node_modules/@vue/reactivity/dist/reactivity.esm-browser.js";
  const state = reactive({ name: "jw", age: 30 });
  effect(() => {
    // 副作用函数 默认执行一次，响应式数据变化后再次执行
    app.innerHTML = state.name + "今年" + state.age + "岁了";
  });
  setTimeout(() => {
    state.age++;
  }, 1000);
</script>
```

> reactive 方法会将对象变成 proxy 对象， effect 中使用 reactive 对象时会进行依赖收集，稍后属性变化时会重新执行 effect 函数~。

## 1.编写 reactive 函数

```js
import { isObject } from "@vue/shared";
function createReactiveObject(target: object, isReadonly: boolean) {
  if (!isObject(target)) {
    return target;
  }
}
// 常用的就是reactive方法
export function reactive(target: object) {
  return createReactiveObject(target, false);
}
// 后面的方法，不是重点我们先不进行实现...
/*
export function shallowReactive(target: object) {
    return createReactiveObject(target, false)
}
export function readonly(target: object) {
    return createReactiveObject(target, true)
}
export function shallowReadonly(target: object) {
    return createReactiveObject(target, true)
}
*/
```

```js
export function isObject(value: unknown) : value is Record<any,any> {
    return typeof value === 'object' && value !== null
}

```

> 由此可知这些方法接受的参数必须是一个对象类型。否则没有任何效果

```js
const reactiveMap = new WeakMap(); // 缓存列表
const mutableHandlers: ProxyHandler<object> = {
  get(target, key, receiver) {
    // 等会谁来取值就做依赖收集
    const res = Reflect.get(target, key, receiver);
    return res;
  },
  set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    const result = Reflect.set(target, key, value, receiver);
    return result;
  },
};
function createReactiveObject(target: object, isReadonly: boolean) {
  if (!isObject(target)) {
    return target;
  }
  const exisitingProxy = reactiveMap.get(target); // 如果已经代理过则直接返回代理后的对象
  if (exisitingProxy) {
    return exisitingProxy;
  }
  const proxy = new Proxy(target, mutableHandlers); // 对对象进行代理
  reactiveMap.set(target, proxy);
  return proxy;
}
```

> 这里必须要使用 Reflect 进行操作，保证 this 指向永远指向代理对象

```js
let person = {
  name: "zuopf",
  get aliasName() {
    return "**" + this.name + "**";
  },
};
let p = new Proxy(person, {
  get(target, key, receiver) {
    console.log(key);
    // return Reflect.get(target,key,receiver)
    return target[key];
  },
});
// 取aliasName时，我希望可以收集aliasName属性和name属性
p.aliasName;
// 这里的问题出自于 target[key] ,target指代的是原对象并不是代理对象
```

> 将对象使用 proxy 进行代理，如果对象已经被代理过，再次重复代理则返回上次代理结果。 那么，如果将一个代理对象传入呢？

```js
const enum ReactiveFlags {
    IS_REACTIVE = '__v_isReactive'
}
const mutableHandlers: ProxyHandler<object> = {
    get(target, key, receiver) {
        if(key === ReactiveFlags.IS_REACTIVE){ // 在get中增加标识，当获取IS_REACTIVE时返回true
            return true;
        }
    }
}
function createReactiveObject(target: object, isReadonly: boolean) {
    if(target[ReactiveFlags.IS_REACTIVE]){ // 在创建响应式对象时先进行取值，看是否已经是响应式对象
        return target
    }
}
```

> 这样我们防止重复代理就做好了~~~

这里我们为了代码方便维护，我们将 mutableHandlers 抽离出去到 baseHandlers.ts 中

## 2.编写 effect 函数

```js
export let activeEffect = undefined;// 当前正在执行的effect 为了方便执行effect的时候依赖收集

export class ReactiveEffect {
  active = true;
  deps = []; // 收集effect中使用到的属性
  // 默认会将fn挂载到类的实例上
  parent = undefined;
  constructor(public fn) { }
  run() {
    try {
      if (!this.active) { // 不是激活状态
        return this.fn();
      }
      this.parent = activeEffect; // 当前的effect就是他的父亲
      activeEffect = this; // 设置成正在激活的是当前effect
      return this.fn();
    } finally {
      activeEffect = this.parent; // 执行完毕后还原activeEffect
      this.parent = undefined;
    }
  }
}
export function effect(fn) {
  // 创建一个响应式effect,并且让effect执行
  const _effect = new ReactiveEffect(fn);
  _effect.run();
}

```

## 3.依赖收集

> 默认执行 effect 时会对属性，进行依赖收集

```js
get(target, key, receiver) {
    if (key === ReactiveFlags.IS_REACTIVE) {
        return true;
    }
    const res = Reflect.get(target, key, receiver);
    track(target, 'get', key);  // 依赖收集
    return res;
}
```

## 4.track 方法实现

```js
const targetMap = new WeakMap();
function track(target, type, key) {
  if (activeEffect) {
    let depsMap = targetMap.get(target); // {对象：map}
    if (!depsMap) {
      targetMap.set(target, (depsMap = new Map())); // 初始化depsMap
    }
    // 获取该属性被哪些effect收集  第一次为false
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, (dep = new Set())); // 初始化该属性的依赖effect {对象：{ 属性 :[ dep, dep ]}}
    }
    // 看是否应该被收集
    let shouldTrack = dep.has(activeEffect);
    if (!shouldTrack) {
      // 把当前活跃的efftct添加到属性的set中
      dep.add(activeEffect);
      // activeEffect收集依赖属性所有的 Set([effect1...]) ，这样后续可以用于清理
      activeEffect.deps.push(dep);
    }
  }
}
```

> 将属性和对应的 effect 维护成映射关系，后续属性变化可以触发对应的 effect 函数重新 run

## 5.触发更新

```js
set(target, key, value, receiver) {
    // 等会赋值的时候可以重新触发effect执行
    let oldValue = target[key]
    const result = Reflect.set(target, key, value, receiver);
    if (oldValue !== value) {
        trigger(target, key, value, oldValue);
    }
    return result;
}
```

```js
export function trigger(target, type, key?, newValue?, oldValue?) {
  const depsMap = targetMap.get(target); // 获取对应的映射表 {属性1：[effect1..],属性2:[effect2...] }
  if (!depsMap) {
    //没有被收集过直接返回
    return;
  }
  const effects = depsMap.get(key); // 查看该属性有没有被effect收集 | 查看该属性收集的effect
  effects &&
    effects.forEach((effect) => {
      // 执行该属性收集的所有effect
      effect.run();
    });
}
```
